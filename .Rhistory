}
invisible(NULL)
}
.accepts_sse <- function(req) {
acc <- req$HTTP_ACCEPT
if (is.null(acc)) return(FALSE)
grepl("text/event-stream", acc, ignore.case = TRUE)
}
# SSE endpoints
pr$handle("GET", "/sse", .sse_handler)
pr$handle("GET", "/stream", .sse_handler)
pr$handle("GET", "/events", .sse_handler)
# JSON-RPC handler at root
pr$handle("POST", "/", function(req, res) {
txt <- req$postBody
if (is.raw(txt)) txt <- rawToChar(txt)
obj <- tryCatch(jsonlite::fromJSON(txt, simplifyVector = FALSE), error = function(e) NULL)
if (is.null(obj)) return(.jsonrpc_error(NULL, -32700, "Parse error"))
# If a session is provided, also emit the response on SSE
q <- .parse_query(req$QUERY_STRING)
sid <- q$sessionId
if (is.null(sid) || !nzchar(as.character(sid))) sid <- q$session
if (is.null(sid) || !nzchar(as.character(sid))) sid <- q$session_id
rsp <- .handle_rpc(obj)
try(.sse_emit(as.character(sid), "message", rsp), silent = TRUE)
rsp
})
# Also accept /rpc path for convenience
pr$handle("POST", "/rpc", function(req, res) {
txt <- req$postBody
if (is.raw(txt)) txt <- rawToChar(txt)
obj <- tryCatch(jsonlite::fromJSON(txt, simplifyVector = FALSE), error = function(e) NULL)
if (is.null(obj)) return(.jsonrpc_error(NULL, -32700, "Parse error"))
q <- .parse_query(req$QUERY_STRING)
sid <- q$sessionId
if (is.null(sid) || !nzchar(as.character(sid))) sid <- q$session
if (is.null(sid) || !nzchar(as.character(sid))) sid <- q$session_id
rsp <- .handle_rpc(obj)
try(.sse_emit(as.character(sid), "message", rsp), silent = TRUE)
rsp
})
# Accept GET / as SSE if client requests it
pr$handle("GET", "/", function(req, res) {
if (.accepts_sse(req)) return(.sse_handler(req, res))
list(status = "ok", message = "MCP server; POST JSON-RPC to '/' or connect SSE at '/sse'")
})
# Start server when executed directly
if (identical(environment(), globalenv())) {
port <- as.integer(Sys.getenv("PORT", unset = 9000))
message(sprintf("[mcp-r] Listening on :%d (JSON-RPC). Tools: %s", port, paste(.TOOLS, collapse = ", ")))
pr$run(host = "0.0.0.0", port = port)
}
#!/usr/bin/env Rscript
# MCP server using the 'mcptools' package (no plumber)
# Registers PortoEdu tools backed by CSV storage defined in R/service.R
options(stringsAsFactors = FALSE)
# Resolve an MCP tools backend package (prefer 'mcptools')
.resolve_mcp_pkg <- function() {
cands <- c("mcptools", "mcpserver", "mcp", "MCPTools")
for (pkg in cands) {
if (requireNamespace(pkg, quietly = TRUE)) return(pkg)
}
stop("No supported MCP server package found. Please install 'mcptools'.", call. = FALSE)
}
.pkg <- .resolve_mcp_pkg()
.ns <- asNamespace(.pkg)
.has <- function(fn) exists(fn, envir = .ns, inherits = FALSE)
.sym <- function(fn) getExportedValue(.pkg, fn)
# Load storage/service helpers
if (file.exists("R/service.R")) source("R/service.R")
# ---- Tool definitions ----
.TOOLS <- c(
"portoedu.create_user",
"portoedu.add_user_data",
"portoedu.get_user",
"portoedu.delete_user",
"portoedu.add_user_context",
"portoedu.clear_user_context",
"portoedu.get_user_context"
)
`%||%` <- function(a, b) if (is.null(a)) b else a
.normalize_arguments <- function(arguments, dots) {
if (!is.null(arguments)) return(arguments)
# Common shapes: list(arguments=..), or plain list of params
if (length(dots) == 1 && is.list(dots[[1]])) {
x <- dots[[1]]
if (!is.null(x$arguments)) return(x$arguments)
return(x)
}
if (length(dots) > 0) return(dots)
list()
}
tool_create_user <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_create_user(name = a$name, id = as.character(a$id), directory = a$directory)
}
tool_add_user_data <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_add_user_data(column_name = a$column_name, data = a$data, name = a$name, id = as.character(a$id), directory = a$directory)
}
tool_get_user <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_get_user(name = a$name, id = as.character(a$id), directory = a$directory)
}
tool_delete_user <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_delete_user(name = a$name, id = as.character(a$id), rm_context = a$rm_context, directory = a$directory)
}
tool_add_user_context <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_add_user_context(context = a$context, user = a$user, id = as.character(a$id), directory = a$directory)
}
tool_clear_user_context <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_clear_user_context(name = a$name, id = as.character(a$id), directory = a$directory)
}
tool_get_user_context <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_get_user_context(name = a$name, user = a$user, id = as.character(a$id), directory = a$directory)
}
.tools_defs <- list(
list(name = "portoedu.create_user", handler = tool_create_user),
list(name = "portoedu.add_user_data", handler = tool_add_user_data),
list(name = "portoedu.get_user", handler = tool_get_user),
list(name = "portoedu.delete_user", handler = tool_delete_user),
list(name = "portoedu.add_user_context", handler = tool_add_user_context),
list(name = "portoedu.clear_user_context", handler = tool_clear_user_context),
list(name = "portoedu.get_user_context", handler = tool_get_user_context)
)
.tools_map <- setNames(lapply(.tools_defs, `[[`, "handler"), sapply(.tools_defs, `[[`, "name"))
# ---- Server bootstrap (try common mcptools shapes) ----
.bind_host <- Sys.getenv("HOST", unset = "0.0.0.0")
.bind_port <- as.integer(Sys.getenv("PORT", unset = 9000))
.try_do <- function(fn, args) {
tryCatch({ do.call(fn, args); TRUE }, error = function(e) FALSE)
}
.start_via_object <- function() {
if (!.has("create_server")) return(FALSE)
create_server <- .sym("create_server")
srv <- create_server()
reg <- NULL
for (cand in c("register_tool", "add_tool")) {
if (.has(cand)) { reg <- .sym(cand); break }
}
if (is.null(reg)) return(FALSE)
# Try to register each tool with several call shapes
mk_tool <- NULL
if (.has("tool")) mk_tool <- .sym("tool")
for (t in .tools_defs) {
ok <- FALSE
# (srv, name, handler)
ok <- ok || .try_do(reg, list(srv, t$name, t$handler))
# (srv, tool_obj)
if (!ok && !is.null(mk_tool)) {
tool_obj <- tryCatch(do.call(mk_tool, list(name = t$name, handler = t$handler)), error = function(e) NULL)
if (!is.null(tool_obj)) ok <- ok || .try_do(reg, list(srv, tool_obj))
}
# (srv, list(name=..., handler=...))
if (!ok) ok <- ok || .try_do(reg, list(srv, list(name = t$name, handler = t$handler)))
if (!ok) message(sprintf("[mcptools] Warning: failed to register tool '%s' with detected API", t$name))
}
runner <- NULL
for (cand in c("run_server", "serve", "start_server", "listen", "run")) {
if (.has(cand)) { runner <- .sym(cand); break }
}
if (is.null(runner)) return(FALSE)
.try_do(runner, list(srv, host = .bind_host, port = .bind_port))
}
.start_via_funcs <- function() {
# Try single-call runners that accept tools directly
for (cand in c("run_server", "serve", "start_server", "start", "listen")) {
if (.has(cand)) {
fn <- .sym(cand)
# Try several shapes
if (.try_do(fn, list(tools = .tools_defs, host = .bind_host, port = .bind_port))) return(TRUE)
if (.try_do(fn, list(tools = .tools_map, host = .bind_host, port = .bind_port))) return(TRUE)
if (.try_do(fn, list(.tools_defs, host = .bind_host, port = .bind_port))) return(TRUE)
if (.try_do(fn, list(.tools_map, host = .bind_host, port = .bind_port))) return(TRUE)
if (.try_do(fn, list(tools = .tools_defs))) return(TRUE)
if (.try_do(fn, list(tools = .tools_map))) return(TRUE)
}
}
FALSE
}
.started <- FALSE
if (!.started) .started <- .start_via_object()
if (!.started) .started <- .start_via_funcs()
if (!.started) {
# Helpful diagnostics
exports <- getNamespaceExports(.pkg)
stop(sprintf("Could not start server via '%s'. Exported functions: %s. Please point me to the correct start/register API of your mcptools package.",
.pkg, paste(head(exports, 50), collapse = ", ")), call. = FALSE)
} else {
message(sprintf("[portoedu-mcp:%s] Listening on %s:%d. Tools: %s", .pkg, .bind_host, .bind_port, paste(.TOOLS, collapse = ", ")))
}
#!/usr/bin/env Rscript
# MCP server using the 'mcptools' package (no plumber)
# Registers PortoEdu tools backed by CSV storage defined in R/service.R
options(stringsAsFactors = FALSE)
# Resolve an MCP tools backend package (prefer 'mcptools')
.resolve_mcp_pkg <- function() {
cands <- c("mcptools", "mcpserver", "mcp", "MCPTools")
for (pkg in cands) {
if (requireNamespace(pkg, quietly = TRUE)) return(pkg)
}
stop("No supported MCP server package found. Please install 'mcptools'.", call. = FALSE)
}
.pkg <- .resolve_mcp_pkg()
.ns <- asNamespace(.pkg)
.has <- function(fn) exists(fn, envir = .ns, inherits = FALSE)
.sym <- function(fn) getExportedValue(.pkg, fn)
# Load storage/service helpers
if (file.exists("R/service.R")) source("R/service.R")
# ---- Tool definitions ----
.TOOLS <- c(
"portoedu.create_user",
"portoedu.add_user_data",
"portoedu.get_user",
"portoedu.delete_user",
"portoedu.add_user_context",
"portoedu.clear_user_context",
"portoedu.get_user_context"
)
`%||%` <- function(a, b) if (is.null(a)) b else a
.normalize_arguments <- function(arguments, dots) {
if (!is.null(arguments)) return(arguments)
# Common shapes: list(arguments=..), or plain list of params
if (length(dots) == 1 && is.list(dots[[1]])) {
x <- dots[[1]]
if (!is.null(x$arguments)) return(x$arguments)
return(x)
}
if (length(dots) > 0) return(dots)
list()
}
tool_create_user <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_create_user(name = a$name, id = as.character(a$id), directory = a$directory)
}
tool_add_user_data <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_add_user_data(column_name = a$column_name, data = a$data, name = a$name, id = as.character(a$id), directory = a$directory)
}
tool_get_user <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_get_user(name = a$name, id = as.character(a$id), directory = a$directory)
}
tool_delete_user <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_delete_user(name = a$name, id = as.character(a$id), rm_context = a$rm_context, directory = a$directory)
}
tool_add_user_context <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_add_user_context(context = a$context, user = a$user, id = as.character(a$id), directory = a$directory)
}
tool_clear_user_context <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_clear_user_context(name = a$name, id = as.character(a$id), directory = a$directory)
}
tool_get_user_context <- function(arguments = list(), ...) {
a <- .normalize_arguments(arguments, list(...))
svc_get_user_context(name = a$name, user = a$user, id = as.character(a$id), directory = a$directory)
}
.tools_defs <- list(
list(name = "portoedu.create_user", handler = tool_create_user),
list(name = "portoedu.add_user_data", handler = tool_add_user_data),
list(name = "portoedu.get_user", handler = tool_get_user),
list(name = "portoedu.delete_user", handler = tool_delete_user),
list(name = "portoedu.add_user_context", handler = tool_add_user_context),
list(name = "portoedu.clear_user_context", handler = tool_clear_user_context),
list(name = "portoedu.get_user_context", handler = tool_get_user_context)
)
.tools_map <- setNames(lapply(.tools_defs, `[[`, "handler"), sapply(.tools_defs, `[[`, "name"))
# ---- Server bootstrap (try common mcptools shapes) ----
.bind_host <- Sys.getenv("HOST", unset = "0.0.0.0")
.bind_port <- as.integer(Sys.getenv("PORT", unset = 9000))
.try_do <- function(fn, args) {
tryCatch({ do.call(fn, args); TRUE }, error = function(e) FALSE)
}
.start_via_object <- function() {
if (!.has("create_server")) return(FALSE)
create_server <- .sym("create_server")
srv <- create_server()
reg <- NULL
for (cand in c("register_tool", "add_tool")) {
if (.has(cand)) { reg <- .sym(cand); break }
}
if (is.null(reg)) return(FALSE)
# Try to register each tool with several call shapes
mk_tool <- NULL
if (.has("tool")) mk_tool <- .sym("tool")
for (t in .tools_defs) {
ok <- FALSE
# (srv, name, handler)
ok <- ok || .try_do(reg, list(srv, t$name, t$handler))
# (srv, tool_obj)
if (!ok && !is.null(mk_tool)) {
tool_obj <- tryCatch(do.call(mk_tool, list(name = t$name, handler = t$handler)), error = function(e) NULL)
if (!is.null(tool_obj)) ok <- ok || .try_do(reg, list(srv, tool_obj))
}
# (srv, list(name=..., handler=...))
if (!ok) ok <- ok || .try_do(reg, list(srv, list(name = t$name, handler = t$handler)))
if (!ok) message(sprintf("[mcptools] Warning: failed to register tool '%s' with detected API", t$name))
}
runner <- NULL
for (cand in c("run_server", "serve", "start_server", "listen", "run")) {
if (.has(cand)) { runner <- .sym(cand); break }
}
if (is.null(runner)) return(FALSE)
.try_do(runner, list(srv, host = .bind_host, port = .bind_port))
}
.start_via_funcs <- function() {
# Try single-call runners that accept tools directly
for (cand in c("run_server", "serve", "start_server", "start", "listen")) {
if (.has(cand)) {
fn <- .sym(cand)
# Try several shapes
if (.try_do(fn, list(tools = .tools_defs, host = .bind_host, port = .bind_port))) return(TRUE)
if (.try_do(fn, list(tools = .tools_map, host = .bind_host, port = .bind_port))) return(TRUE)
if (.try_do(fn, list(.tools_defs, host = .bind_host, port = .bind_port))) return(TRUE)
if (.try_do(fn, list(.tools_map, host = .bind_host, port = .bind_port))) return(TRUE)
if (.try_do(fn, list(tools = .tools_defs))) return(TRUE)
if (.try_do(fn, list(tools = .tools_map))) return(TRUE)
}
}
FALSE
}
.start_via_mcptools <- function() {
if (!(.has("mcp_server") || .has("mcp_tools"))) return(FALSE)
mcp_server <- if (.has("mcp_server")) .sym("mcp_server") else NULL
mcp_tools <- if (.has("mcp_tools")) .sym("mcp_tools") else NULL
# Build tools registry/object if creator exists, otherwise pass raw defs
reg <- NULL
if (!is.null(mcp_tools)) {
# Try multiple call shapes to create a registry/collection
for (args in list(
list(.tools_defs),
list(.tools_map),
list(tools = .tools_defs),
list(tools = .tools_map),
list(definitions = .tools_defs),
list(definitions = .tools_map)
)) {
reg <- tryCatch(do.call(mcp_tools, args), error = function(e) NULL)
if (!is.null(reg)) break
}
}
# Start server with registry or raw tool defs
if (!is.null(mcp_server)) {
# Try various shapes
for (args in list(
list(tools = reg, host = .bind_host, port = .bind_port),
list(reg, host = .bind_host, port = .bind_port),
list(tools = .tools_defs, host = .bind_host, port = .bind_port),
list(tools = .tools_map, host = .bind_host, port = .bind_port),
list(.tools_defs, host = .bind_host, port = .bind_port),
list(.tools_map, host = .bind_host, port = .bind_port),
list(tools = reg),
list(reg),
list(tools = .tools_defs),
list(tools = .tools_map),
list(.tools_defs),
list(.tools_map)
)) {
ok <- .try_do(mcp_server, args)
if (ok) return(TRUE)
}
}
FALSE
}
.started <- FALSE
if (!.started) .started <- .start_via_mcptools()
if (!.started) .started <- .start_via_object()
if (!.started) .started <- .start_via_funcs()
if (!.started) {
# Helpful diagnostics
exports <- getNamespaceExports(.pkg)
stop(sprintf("Could not start server via '%s'. Exported functions: %s. Please point me to the correct start/register API of your mcptools package.",
.pkg, paste(head(exports, 50), collapse = ", ")), call. = FALSE)
} else {
message(sprintf("[portoedu-mcp:%s] Listening on %s:%d. Tools: %s", .pkg, .bind_host, .bind_port, paste(.TOOLS, collapse = ", ")))
}
#!/usr/bin/env Rscript
# Diagnóstico do ambiente
cat("=== DIAGNÓSTICO PORTOEDU MCP ===\n\n")
# 1. Verifica R/service.R
cat("[1] Verificando R/service.R:\n")
if (file.exists("R/service.R")) {
cat("  ✓ Arquivo existe\n")
tryCatch({
source("R/service.R")
cat("  ✓ Carregou sem erros\n")
# Verifica funções esperadas
funcs <- c("svc_create_user", "svc_add_user_data", "svc_get_user",
"svc_delete_user", "svc_add_user_context", "svc_clear_user_context",
"svc_get_user_context")
for(f in funcs) {
if(exists(f)) cat(sprintf("  ✓ %s() encontrada\n", f))
else cat(sprintf("  ✗ %s() NÃO encontrada\n", f))
}
}, error = function(e) {
cat(sprintf("  ✗ ERRO ao carregar: %s\n", e$message))
})
} else {
cat("  ✗ Arquivo NÃO existe\n")
}
# 2. Verifica pacotes MCP
cat("\n[2] Verificando pacotes MCP:\n")
cands <- c("mcptools", "mcpserver", "mcp", "MCPTools")
for(pkg in cands) {
if(requireNamespace(pkg, quietly = TRUE)) {
cat(sprintf("  ✓ %s instalado\n", pkg))
cat(sprintf("    Funções exportadas: %s\n",
paste(head(getNamespaceExports(pkg), 10), collapse=", ")))
} else {
cat(sprintf("  ✗ %s NÃO instalado\n", pkg))
}
}
# 3. Testa bind de porta
cat("\n[3] Testando porta 9000:\n")
tryCatch({
s <- socketConnection(host="0.0.0.0", port=9000, server=TRUE,
blocking=FALSE, open="r+", timeout=1)
cat("  ✓ Porta 9000 disponível\n")
close(s)
}, error = function(e) {
cat(sprintf("  ⚠ Problema com porta: %s\n", e$message))
})
cat("\n=== FIM DO DIAGNÓSTICO ===\n")
#!/usr/bin/env Rscript
# Diagnóstico do ambiente
cat("=== DIAGNÓSTICO PORTOEDU MCP ===\n\n")
# 1. Verifica R/service.R
cat("[1] Verificando R/service.R:\n")
if (file.exists("R/service.R")) {
cat("  ✓ Arquivo existe\n")
tryCatch({
source("R/service.R")
cat("  ✓ Carregou sem erros\n")
# Verifica funções esperadas
funcs <- c("svc_create_user", "svc_add_user_data", "svc_get_user",
"svc_delete_user", "svc_add_user_context", "svc_clear_user_context",
"svc_get_user_context")
for(f in funcs) {
if(exists(f)) cat(sprintf("  ✓ %s() encontrada\n", f))
else cat(sprintf("  ✗ %s() NÃO encontrada\n", f))
}
}, error = function(e) {
cat(sprintf("  ✗ ERRO ao carregar: %s\n", e$message))
})
} else {
cat("  ✗ Arquivo NÃO existe\n")
}
# 2. Verifica pacotes MCP
cat("\n[2] Verificando pacotes MCP:\n")
cands <- c("mcptools", "mcpserver", "mcp", "MCPTools")
for(pkg in cands) {
if(requireNamespace(pkg, quietly = TRUE)) {
cat(sprintf("  ✓ %s instalado\n", pkg))
cat(sprintf("    Funções exportadas: %s\n",
paste(head(getNamespaceExports(pkg), 10), collapse=", ")))
} else {
cat(sprintf("  ✗ %s NÃO instalado\n", pkg))
}
}
# 3. Testa bind de porta
cat("\n[3] Testando porta 9000:\n")
tryCatch({
s <- socketConnection(host="0.0.0.0", port=9000, server=TRUE,
blocking=FALSE, open="r+", timeout=1)
cat("  ✓ Porta 9000 disponível\n")
close(s)
}, error = function(e) {
cat(sprintf("  ⚠ Problema com porta: %s\n", e$message))
})
cat("\n=== FIM DO DIAGNÓSTICO ===\n")
#!/usr/bin/env Rscript
library(mcptools)
source("R/service.R")
cat("=== TESTE DIRETO MCPTOOLS ===\n\n")
# Wrapper simples
tools_list <- list(
list(
name = "portoedu.get_user",
description = "Recupera dados de um usuário",
inputSchema = list(
type = "object",
properties = list(
name = list(type = "string"),
id = list(type = "string"),
directory = list(type = "string")
)
),
handler = function(arguments) {
cat(sprintf("[DEBUG] get_user chamado: %s\n",
paste(names(arguments), arguments, sep="=", collapse=", ")))
svc_get_user(
name = arguments$name,
id = as.character(arguments$id),
directory = arguments$directory
)
}
)
)
cat("[1] Criando servidor...\n")
server <- tryCatch({
mcp_server(tools = tools_list, host = "0.0.0.0", port = 9000)
}, error = function(e) {
cat(sprintf("ERRO ao criar: %s\n", e$message))
cat("Tentando sem host/port...\n")
mcp_server(tools = tools_list)
})
